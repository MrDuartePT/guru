--- a/CHANGELOG
+++ b/CHANGELOG
@@ -0,0 +1,10 @@
+* 2000-04-13 Pierangelo Masarati <masarati@aero.polimi.it>
+ - fixed HUGE_VAL configure
+ - prefixed REAL, DOUBLE and FLOAT with MESCHACH_ to avoid conflicts
+
+* 2000-??-?? Pierangelo Masarati <masarati@aero.polimi.it>
+ - changed the struct pair in sparse.h to avoid conflicts with C++ stl
+ - added some helpers for adding and subtracting coefs from sparse matrices
+ - WARNING: in C++ the macro `catch' conflicts with the exception handling
+   keyword; I temporarily fixed the problem by #undef-ining it after including
+   meschach headers.
--- a/init.c
+++ b/init.c
@@ -59,7 +59,7 @@
    if ( ix == IVNULL )
      error(E_NULL,"iv_zero");
    
-   for ( i = 0; i < ix->dim; i++ )
+   for ( i = ix->dim; i-- > 0; )
      ix->ive[i] = 0; 
    
    return ix;
@@ -77,7 +77,7 @@
 		error(E_NULL,"m_zero");
 
 	A_m = A->m;	A_n = A->n;	A_me = A->me;
-	for ( i = 0; i < A_m; i++ )
+	for ( i = A_m; i-- > 0; )
 		__zero__(A_me[i],A_n);
 		/* for ( j = 0; j < A_n; j++ )
 			A_me[i][j] = 0.0; */
@@ -97,7 +97,7 @@
 
 	m_zero(A);
 	size = min(A->m,A->n);
-	for ( i = 0; i < size; i++ )
+	for ( i = size; i-- > 0; )
 		A->me[i][i] = 1.0;
 
 	return A;
@@ -114,7 +114,7 @@
 		error(E_NULL,"px_ident");
 
 	px_size = px->size;	px_pe = px->pe;
-	for ( i = 0; i < px_size; i++ )
+	for ( i = px_size; i-- > 0; )
 		px_pe[i] = i;
 
 	return px;
@@ -178,7 +178,7 @@
     if ( ! started )
 	smrand(3127);
     
-    for ( i = 0; i < len; i++ )
+    for ( i = len; i-- > 0; )
     {
 	inext = (inext >= 54) ? 0 : inext+1;
 	inextp = (inextp >= 54) ? 0 : inextp+1;
@@ -260,12 +260,28 @@
 	if ( ! x )
 		error(E_NULL,"v_ones");
 
-	for ( i = 0; i < x->dim; i++ )
+	for ( i = x->dim; i-- > 0; )
 		x->ve[i] = 1.0;
 
 	return x;
 }
 
+/* v_init -- fills x with d's */
+VEC	*v_init(x, d)
+VEC	*x;
+Real    d;
+{
+	int	i;
+
+	if ( ! x )
+		error(E_NULL,"v_ones");
+
+	for ( i = x->dim; i-- > 0; )
+		x->ve[i] = d;
+
+	return x;
+}
+
 /* m_ones -- fills matrix with one's */
 MAT	*m_ones(A)
 MAT	*A;
@@ -275,8 +291,8 @@
 	if ( ! A )
 		error(E_NULL,"m_ones");
 
-	for ( i = 0; i < A->m; i++ )
-		for ( j = 0; j < A->n; j++ )
+	for ( i = A->m; i-- > 0; )
+		for ( j = A->n; j-- > 0; )
 		    A->me[i][j] = 1.0;
 
 	return A;
@@ -291,7 +307,7 @@
 	if ( ! x )
 	    error(E_NULL,"v_count");
 
-	for ( i = 0; i < x->dim; i++ )
+	for ( i = x->dim; i-- > 0; )
 	    x->ve[i] = (Real)i;
 
 	return x;
--- a/itertort.c
+++ b/itertort.c
@@ -41,10 +41,10 @@
   
   /* for iterative methods */
   
-#if REAL == DOUBLE
+#if MESCHACH_REAL == MESCHACH_DOUBLE
 #define	EPS	1e-7
 #define KK	20
-#elif REAL == FLOAT
+#elif MESCHACH_REAL == MESCHACH_FLOAT
 #define EPS   1e-5
 #define KK	8
 #endif
--- a/machine.h.in
+++ b/machine.h.in
@@ -16,14 +16,15 @@
 #undef MALLOCDECL
 #undef NOT_SEGMENTED
 #undef HAVE_MEMORY_H
-#undef HAVE_COMPLEX_H
+/* #undef HAVE_COMPLEX_H */
 #undef HAVE_MALLOC_H
+#undef HAVE_HUGE_VAL_H
 #undef STDC_HEADERS
 #undef HAVE_BCOPY
 #undef HAVE_BZERO
 #undef CHAR0ISDBL0
 #undef WORDS_BIGENDIAN
-#undef U_INT_DEF
+/* #undef U_INT_DEF */
 #undef VARARGS
 #undef HAVE_PROTOTYPES
 #undef HAVE_PROTOTYPES_IN_STRUCT
@@ -53,7 +54,7 @@
 #endif /* HAVE_PROTOTYPES_IN_STRUCT */
 
 /* for basic or larger versions */
-#undef COMPLEX
+#undef MESCHACH_COMPLEX
 #undef SPARSE
 
 /* for loop unrolling */
@@ -131,9 +132,9 @@
 
 /* you can choose single, double or long double (if available) precision */
 
-#define FLOAT 		1
-#define DOUBLE 		2
-#define LONG_DOUBLE 	3
+#define MESCHACH_FLOAT 	1
+#define MESCHACH_DOUBLE	2
+#define MESCHACH_LONG_DOUBLE 	3
 
 #undef REAL_FLT
 #undef REAL_DBL
@@ -149,27 +150,27 @@
 #ifdef REAL_FLT
 #define  Real float
 #define  LongReal float
-#define REAL FLOAT
-#define LONGREAL FLOAT
+#define MESCHACH_REAL MESCHACH_FLOAT
+#define MESCHACH_LONGREAL MESCHACH_FLOAT
 #endif
 
 /* double precision */
 #ifdef REAL_DBL
 #define Real double
 #define LongReal double
-#define REAL DOUBLE
-#define LONGREAL DOUBLE
+#define MESCHACH_REAL MESCHACH_DOUBLE
+#define MESCHACH_LONGREAL MESCHACH_DOUBLE
 #endif
 
 
 /* machine epsilon or unit roundoff error */
 /* This is correct on most IEEE Real precision systems */
 #ifdef DBL_EPSILON
-#if REAL == DOUBLE
+#if MESCHACH_REAL == MESCHACH_DOUBLE
 #define	MACHEPS	DBL_EPSILON
-#elif REAL == FLOAT
+#elif MESCHACH_REAL == MESCHACH_FLOAT
 #define	MACHEPS	FLT_EPSILON
-#elif REAL == LONGDOUBLE
+#elif MESCHACH_REAL == MESCHACH_LONGDOUBLE
 #define MACHEPS LDBL_EPSILON
 #endif
 #endif
@@ -178,11 +179,11 @@
 #undef D_MACHEPS
 
 #ifndef MACHEPS
-#if REAL == DOUBLE
+#if MESCHACH_REAL == MESCHACH_DOUBLE
 #define	MACHEPS	D_MACHEPS
-#elif REAL == FLOAT  
+#elif MESCHACH_REAL == MESCHACH_FLOAT  
 #define MACHEPS F_MACHEPS
-#elif REAL == LONGDOUBLE
+#elif MESCHACH_REAL == MESCHACH_LONGDOUBLE
 #define MACHEPS D_MACHEPS
 #endif
 #endif
@@ -208,12 +209,16 @@
 #endif
 
 /* for non-ANSI systems */
+#ifndef HAVE_HUGE_VAL_H
 #ifndef HUGE_VAL
 #define HUGE_VAL HUGE
 #else
 #ifndef HUGE
 #define HUGE HUGE_VAL
 #endif
+#endif
+#else
+#define HUGE HUGE_VAL
 #endif
 
 
--- a/matlab.h
+++ b/matlab.h
@@ -66,9 +66,9 @@
 
 #define ORDER           ROW_ORDER
 
-#if REAL == DOUBLE
+#if MESCHACH_REAL == MESCHACH_DOUBLE
 #define PRECISION       DOUBLE_PREC
-#elif REAL == FLOAT
+#elif MESCHACH_REAL == MESCHACH_FLOAT
 #define PRECISION  	SINGLE_PREC
 #endif
 
@@ -90,7 +90,7 @@
 #endif
 
 /* complex variant */
-#ifdef COMPLEX
+#ifdef MESCHACH_COMPLEX
 #include "zmatrix.h"
 
 #ifdef ANSI_C
--- a/matrix.h
+++ b/matrix.h
@@ -384,11 +384,17 @@
 /* Initialisation routines -- to be zero, ones, random or identity */
 #ifndef ANSI_C
 extern	VEC     *v_zero(), *v_rand(), *v_ones();
+/* ANDO 01-13-99 */
+extern	VEC     *v_init();
+/* ODNA 01-13-99 */
 extern	MAT     *m_zero(), *m_ident(), *m_rand(), *m_ones();
 extern	PERM    *px_ident();
 extern  IVEC    *iv_zero();
 #else
 extern	VEC     *v_zero(VEC *), *v_rand(VEC *), *v_ones(VEC *);
+/* ANDO 01-13-99 */
+extern	VEC     *v_init(VEC*, Real);
+/* ODNA 01-13-99 */
 extern	MAT     *m_zero(MAT *), *m_ident(MAT *), *m_rand(MAT *),
 						*m_ones(MAT *);
 extern	PERM    *px_ident(PERM *);
--- a/matrixio.c
+++ b/matrixio.c
@@ -124,9 +124,9 @@
 		    {   j--;    dynamic = FALSE;        goto redo2;     }
 		    if ( (*line == 'f' || *line == 'F') && j < n-1 )
 		    {   j++;    dynamic = FALSE;        goto redo2;     }
-#if REAL == DOUBLE
+#if MESCHACH_REAL == MESCHACH_DOUBLE
 	       } while ( *line=='\0' || sscanf(line,"%lf",&mat->me[i][j])<1 );
-#elif REAL == FLOAT
+#elif MESCHACH_REAL == MESCHACH_FLOAT
 	       } while ( *line=='\0' || sscanf(line,"%f",&mat->me[i][j])<1 );
 #endif
 	  fprintf(stderr,"Continue: ");
@@ -168,9 +168,9 @@
 	  if ( fscanf(fp," row %u:",&dummy) < 1 )
 	       error(E_FORMAT,"bm_finput");
 	  for ( j=0; j<n; j++ )
-#if REAL == DOUBLE
+#if MESCHACH_REAL == MESCHACH_DOUBLE
 	       if ((io_code=fscanf(fp,"%lf",&mat->me[i][j])) < 1 )
-#elif REAL == FLOAT
+#elif MESCHACH_REAL == MESCHACH_FLOAT
 	       if ((io_code=fscanf(fp,"%f",&mat->me[i][j])) < 1 )
 #endif
 		    error(io_code==EOF ? 7 : 6,"bm_finput");
@@ -337,9 +337,9 @@
 	       {        i--;    dynamic = FALSE;        goto redo;         }
 	       if ( (*line == 'f' || *line == 'F') && i < dim-1 )
 	       {        i++;    dynamic = FALSE;        goto redo;         }
-#if REAL == DOUBLE
+#if MESCHACH_REAL == MESCHACH_DOUBLE
 	  } while ( *line=='\0' || sscanf(line,"%lf",&vec->ve[i]) < 1 );
-#elif REAL == FLOAT
+#elif MESCHACH_REAL == MESCHACH_FLOAT
           } while ( *line=='\0' || sscanf(line,"%f",&vec->ve[i]) < 1 );
 #endif
      
@@ -367,9 +367,9 @@
      /* get entries */
      skipjunk(fp);
      for ( i=0; i<dim; i++ )
-#if REAL == DOUBLE
+#if MESCHACH_REAL == MESCHACH_DOUBLE
 	  if ((io_code=fscanf(fp,"%lf",&vec->ve[i])) < 1 )
-#elif REAL == FLOAT
+#elif MESCHACH_REAL == MESCHACH_FLOAT
 	  if ((io_code=fscanf(fp,"%f",&vec->ve[i])) < 1 )
 #endif
 	       error(io_code==EOF ? 7 : 6,"bfin_vec");
--- a/meminfo.c
+++ b/meminfo.c
@@ -34,7 +34,7 @@
 #include <stdio.h>
 #include  "matrix.h"
 #include  "meminfo.h"
-#ifdef COMPLEX   
+#ifdef MESCHACH_COMPLEX   
 #include  "zmatrix.h"
 #endif
 #ifdef SPARSE
@@ -60,7 +60,7 @@
      "SPROW",
      "SPMAT"
 #endif
-#ifdef COMPLEX   
+#ifdef MESCHACH_COMPLEX   
        ,"ZVEC",
        "ZMAT"
 #endif
@@ -86,7 +86,7 @@
      sprow_free, 
      sp_free
 #endif
-#ifdef COMPLEX
+#ifdef MESCHACH_COMPLEX
        ,zv_free,	
        zm_free
 #endif
--- a/meminfo.h
+++ b/meminfo.h
@@ -58,7 +58,7 @@
 #define TYPE_SPMAT		7
 #endif
 
-#ifdef COMPLEX
+#ifdef MESCHACH_COMPLEX
 #ifdef SPARSE
 #define TYPE_ZVEC		8
 #define TYPE_ZMAT		9
--- a/memtort.c
+++ b/memtort.c
@@ -318,7 +318,7 @@
 }
 #endif
 
-#ifdef COMPLEX
+#ifdef MESCHACH_COMPLEX
 void stat_test4(par)
 int par;
 {
@@ -355,7 +355,7 @@
    IVEC *ix = IVNULL, *iy = IVNULL, *iz = IVNULL;
    int m,n,i,j,deg,k;
    Real s1,s2;
-#ifdef COMPLEX
+#ifdef MESCHACH_COMPLEX
    ZVEC        *zx = ZVNULL, *zy = ZVNULL, *zz = ZVNULL;
    ZMAT        *zA = ZMNULL, *zB = ZMNULL, *zC = ZMNULL;
    complex     ONE;
@@ -580,7 +580,7 @@
 #endif  /* SPARSE */   
 
 
-#ifdef COMPLEX
+#ifdef MESCHACH_COMPLEX
    /* complex stuff */
    
    ONE = zmake(1.0,0.0);
@@ -629,7 +629,7 @@
      errmesg("ZMAT resize");
    
    zm_free_vars(&zA,&zB,&zC,NULL);
-#endif /* COMPLEX */
+#endif /* MESCHACH_COMPLEX */
 
 #endif  /* if defined(ANSI_C) || defined(VARARGS) */
 
@@ -647,7 +647,7 @@
    mem_stat_mark(1);
    for (i=0; i < 100; i++) {
      stat_test1(i);
-#ifdef COMPLEX
+#ifdef MESCHACH_COMPLEX
      stat_test4(i);
 #endif
   }
@@ -671,7 +671,7 @@
 
    for (i=0; i < 100; i++) {
       stat_test1(i);
-#ifdef COMPLEX
+#ifdef MESCHACH_COMPLEX
       stat_test4(i);
 #endif
    } 
@@ -727,9 +727,9 @@
 
    mem_info();
    
-#if REAL == FLOAT
+#if MESCHACH_REAL == MESCHACH_FLOAT
    printf("# SINGLE PRECISION was used\n");
-#elif REAL == DOUBLE
+#elif MESCHACH_REAL == MESCHACH_DOUBLE
    printf("# DOUBLE PRECISION was used\n");
 #endif
 
@@ -744,9 +744,9 @@
 #ifdef ANSI_OR_VAR
 
    printf("# you should get: \n");
-#if (REAL == FLOAT)
+#if (MESCHACH_REAL == MESCHACH_FLOAT)
      printf("#   type VEC: 276 bytes allocated, 3 variables allocated\n");
-#elif (REAL == DOUBLE)
+#elif (MESCHACH_REAL == MESCHACH_DOUBLE)
      printf("#   type VEC: 516 bytes allocated, 3 variables allocated\n");
 #endif
    printf("#   and other types are zeros\n");
--- a/otherio.c
+++ b/otherio.c
@@ -130,9 +130,9 @@
 	if ( ! isatty(fileno(fp)) )
 	{
 		skipjunk(fp);
-#if REAL == DOUBLE
+#if MESCHACH_REAL == MESCHACH_DOUBLE
 		if ( (retcode=fscanf(fp,"%lf",&x)) == EOF )
-#elif REAL == FLOAT
+#elif MESCHACH_REAL == MESCHACH_FLOAT
 		if ( (retcode=fscanf(fp,"%f",&x)) == EOF )
 #endif
 			error(E_INPUT,"fin_double");
@@ -148,9 +148,9 @@
 		fprintf(stderr,"%s: ",s);
 		if ( fgets(scratch,MAXLINE,stdin)==NULL )
 			error(E_INPUT,"fin_double");
-#if REAL == DOUBLE
+#if MESCHACH_REAL == MESCHACH_DOUBLE
 		retcode = sscanf(scratch,"%lf",&x);
-#elif REAL == FLOAT 
+#elif MESCHACH_REAL == MESCHACH_FLOAT 
 		retcode = sscanf(scratch,"%f",&x);
 #endif
 		if ( ( retcode==1 && low > high ) ||
--- a/rk4.dat
+++ b/rk4.dat
@@ -1,12 +0,0 @@
-# No. of a problem
-1
-# Initial time
-0
-# Final time
-1
-# Solution is x(t) = (cos(t),-sin(t))
-# x(0) =
-Vector: dim: 2
-1       0
-# Step size
-0.1
--- a/sparse.c
+++ b/sparse.c
@@ -61,25 +61,33 @@
    return r->elt[idx].val;
 }
 
+void _set(d, s)  double* d; double s; { *d = s; }
+void _inc(d, s)  double* d; double s; { *d += s; }
+void _dec(d, s)  double* d; double s; { *d -= s; }
+
 /* sp_set_val -- sets the (i,j) entry of the sparse matrix A */
-double	sp_set_val(A,i,j,val)
+double	sp_set_val_(A,i,j,val,f)
 SPMAT	*A;
 int	i, j;
 double	val;
+void (*f)(double*, double);
 {
    SPROW	*r;
    int	idx, idx2, new_len;
    
    if ( A == SMNULL )
-     error(E_NULL,"sp_set_val");
+     error(E_NULL,"sp_set_val_");
    if ( i < 0 || i >= A->m || j < 0 || j >= A->n )
-     error(E_SIZES,"sp_set_val");
+     error(E_SIZES,"sp_set_val_");
    
    r = A->row+i;
    idx = sprow_idx(r,j);
-   /* printf("sp_set_val: idx = %d\n",idx); */
+   /* printf("sp_set_val_: idx = %d\n",idx); */
    if ( idx >= 0 )
-   {	r->elt[idx].val = val;	return val;	}
+   {
+      (*f)(&(r->elt[idx].val), val);
+      return r->elt[idx].val;	
+   }
    /* else */ if ( idx < -1 )
    {
       /* Note: this destroys the column & diag access paths */
@@ -97,7 +105,7 @@
 
 	 r->elt = RENEW(r->elt,new_len,row_elt);
 	 if ( ! r->elt )	/* can't allocate */
-	   error(E_MEM,"sp_set_val");
+	   error(E_MEM,"sp_set_val_");
 	 r->maxlen = 2*r->maxlen+1;
       }
       for ( idx2 = r->len-1; idx2 >= idx; idx2-- )
@@ -110,12 +118,40 @@
 	************************************************************/
       r->len++;
       r->elt[idx].col = j;
+      
+      /* sbagliato
+      (*f)(&(r->elt[idx].val), val);
+       */
       return r->elt[idx].val = val;
    }
    /* else -- idx == -1, error in index/matrix! */
    return 0.0;
 }
 
+double	sp_set_val(A,i,j,val)
+SPMAT	*A;
+int	i, j;
+double	val;
+{
+   return sp_set_val_(A, i, j, val, _set);
+}
+
+double	sp_inc_val(A,i,j,val)
+SPMAT	*A;
+int	i, j;
+double	val;
+{
+   return sp_set_val_(A, i, j, val, _inc);
+}
+
+double	sp_dec_val(A,i,j,val)
+SPMAT	*A;
+int	i, j;
+double	val;
+{
+   return sp_set_val_(A, i, j, val, _dec);
+}
+
 /* sp_mv_mlt -- sparse matrix/dense vector multiply
    -- result is in out, which is returned unless out==NULL on entry
    --  if out==NULL on entry then the result vector is created */
@@ -612,16 +648,17 @@
 {
    int i;
 
-   if ( ! A )
-     error(E_NULL,"sp_smlt");
-   if ( ! B )
-     B = sp_get(A->m,A->n,5);
-   else
-     if ( A->m != B->m || A->n != B->n )
-       error(E_SIZES,"sp_smlt");
+   if (!A) {
+      error(E_NULL, "sp_smlt");
+   }
+   if (!B) {
+      B = sp_get(A->m, A->n, 5);
+   } else if (A->m != B->m || A->n != B->n) {
+      error(E_SIZES, "sp_smlt");
+   }
 
-   for (i=0; i < A->m; i++) {
-      sprow_smlt(&(A->row[i]),alpha,0,&(B->row[i]),TYPE_SPMAT);
+   for (i = A->m; i-- > 0; ) {
+      sprow_smlt(&(A->row[i]), alpha, 0, &(B->row[i]), TYPE_SPMAT);
    }
    return B;
 }
@@ -635,15 +672,16 @@
    int	i, idx, len;
    row_elt	*elt;
    
-   if ( ! A )
-     error(E_NULL,"sp_zero");
+   if ( ! A ) {
+      error(E_NULL,"sp_zero");
+   }
    
-   for ( i = 0; i < A->m; i++ )
-   {
+   for ( i = A->m; i-- > 0; ) {
       elt = A->row[i].elt;
       len = A->row[i].len;
-      for ( idx = 0; idx < len; idx++ )
-	(*elt++).val = 0.0;
+      for ( idx = len; idx-- > 0; ) {
+	 (*elt++).val = 0.;
+      }
    }
    
    return A;
--- a/sparse.h
+++ b/sparse.h
@@ -63,11 +63,12 @@
 	This starts the chain down the columns using the nxt_row and nxt_idx
 	fields of each entry in each row. */
 
-typedef struct pair { int pos;	Real val; } pair;
+typedef struct meschach_pair { int pos;	Real val; } meschach_pair;
 
 typedef struct SPVEC {
 	int	dim, max_dim;
-	pair	*elt;		/* elt[max_dim] */
+	struct { int pos; Real val; } *elt;
+	/* meschach_pair	*elt; */		/* elt[max_dim] */
 	       } SPVEC;
 
 #define	SMNULL	((SPMAT*)NULL)
@@ -98,6 +99,9 @@
 extern	SPMAT	*sp_get(), *sp_copy(), *sp_copy2(),
 			*sp_zero(), *sp_resize(), *sp_compact();
 extern	double	sp_get_val(), sp_set_val();
+/* ANDO 01-10-99 */
+extern	double sp_inc_val(), sp_dec_val();
+/* ANDO 01-10-99 */
 extern	VEC	*sp_mv_mlt(), *sp_vm_mlt();
 extern	int	sp_free();
 
@@ -132,6 +136,9 @@
 	*sp_zero(SPMAT *), *sp_resize(SPMAT *,int,int),
 	*sp_compact(SPMAT *,double);
 double	sp_get_val(SPMAT *,int,int), sp_set_val(SPMAT *,int,int,double);
+/* ANDO 01-10-99 */
+double  sp_inc_val(SPMAT *,int,int,double), sp_dec_val(SPMAT *,int,int,double);
+/* ANDO 01-10-99 */
 VEC	*sp_mv_mlt(SPMAT *,VEC *,VEC *), *sp_vm_mlt(SPMAT *,VEC *,VEC *);
 int	sp_free(SPMAT *);
 
--- a/sparseio.c
+++ b/sparseio.c
@@ -222,9 +222,9 @@
 				error(E_INPUT,"sp_finput");
 			    if ( *line == 'e' || *line == 'E' )
 				break;
-#if REAL == DOUBLE
+#if MESCHACH_REAL == MESCHACH_DOUBLE
 			} while ( sscanf(line,"%u %lf",&col,&val) != 2 ||
-#elif REAL == FLOAT
+#elif MESCHACH_REAL == MESCHACH_FLOAT
 			} while ( sscanf(line,"%u %f",&col,&val) != 2 ||
 #endif
 				    col >= n || col <= curr_col );
@@ -282,9 +282,9 @@
 		    curr_col = -1;
 		    for ( len = 0; len < MAXSCRATCH; len++ )
 		    {
-#if REAL == DOUBLE
+#if MESCHACH_REAL == MESCHACH_DOUBLE
 			if ( (ret_val=fscanf(fp,"%u : %lf",&col,&val)) != 2 )
-#elif REAL == FLOAT
+#elif MESCHACH_REAL == MESCHACH_FLOAT
 			if ( (ret_val=fscanf(fp,"%u : %f",&col,&val)) != 2 )
 #endif
 			    break;
--- a/splufctr.c
+++ b/splufctr.c
@@ -56,21 +56,27 @@
 	Real	max_val, tmp;
 	static VEC	*col_vals=VNULL;
 
-	if ( ! A || ! px )
+	if ( ! A || ! px ) {
 		error(E_NULL,"spLUfctr");
-	if ( alpha <= 0.0 || alpha > 1.0 )
+	}
+	if ( alpha <= 0.0 || alpha > 1.0 ) {
 		error(E_RANGE,"alpha in spLUfctr");
-	if ( px->size <= A->m )
+	}
+	if ( px->size <= A->m ) {
 		px = px_resize(px,A->m);
+	}
 	px_ident(px);
 	col_vals = v_resize(col_vals,A->m);
 	MEM_STAT_REG(col_vals,TYPE_VEC);
 
-	m = A->m;	n = A->n;
-	if ( ! A->flag_col )
+	m = A->m;	
+        n = A->n;
+	if ( ! A->flag_col ) {
 		sp_col_access(A);
-	if ( ! A->flag_diag )
+	}
+	if ( ! A->flag_diag ) {
 		sp_diag_access(A);
+	}
 	A->flag_col = A->flag_diag = FALSE;
 	if ( ! merge ) {
 	   merge = sprow_get(20);
@@ -87,25 +93,29 @@
 	    {
 		r = &(A->row[i]);
 		idx = sprow_idx(r,k);
-		if ( idx < 0 )
+		if ( idx < 0 ) {
 		    tmp = 0.0;
-		else
+		} else {
 		    tmp = r->elt[idx].val;
-		if ( fabs(tmp) > max_val )
+		}
+		if ( fabs(tmp) > max_val ) {
 		    max_val = fabs(tmp);
+		}
 		col_vals->ve[i] = tmp;
 	    }
 
-	    if ( max_val == 0.0 )
+	    if ( max_val == 0.0 ) {
 		continue;
+	    }
 
 	    best_len = n+1;	/* only if no possibilities */
 	    best_i = -1;
 	    for ( i = k; i < m; i++ )
 	    {
 		tmp = fabs(col_vals->ve[i]);
-		if ( tmp == 0.0 )
+		if ( tmp == 0.0 ) {
 		    continue;
+		}
 		if ( tmp >= alpha*max_val )
 		{
 		    r = &(A->row[i]);
@@ -171,17 +181,21 @@
 	SPROW	*r;
 	row_elt	*elt;
 
-	if ( ! A || ! b )
+	if ( ! A || ! b ) {
 	    error(E_NULL,"spLUsolve");
-	if ( (pivot != PNULL && A->m != pivot->size) || A->m != b->dim )
+	}
+	if ( (pivot != PNULL && A->m != pivot->size) || A->m != b->dim ) {
 	    error(E_SIZES,"spLUsolve");
-	if ( ! x || x->dim != A->n )
+	}
+	if ( ! x || x->dim != A->n ) {
 	    x = v_resize(x,A->n);
+	}
 
-	if ( pivot != PNULL )
+	if ( pivot != PNULL ) {
 	    x = px_vec(pivot,b,x);
-	else
+	} else {
 	    x = v_copy(b,x);
+	}
 
 	x_ve = x->ve;
 	lim = min(A->m,A->n);
@@ -191,21 +205,24 @@
 	    r = &(A->row[i]);
 	    len = r->len;
 	    elt = r->elt;
-	    for ( idx = 0; idx < len && elt->col < i; idx++, elt++ )
+	    for ( idx = 0; idx < len && elt->col < i; idx++, elt++ ) {
 		sum -= elt->val*x_ve[elt->col];
+	    }
 	    x_ve[i] = sum;
 	}
 
-	for ( i = lim-1; i >= 0; i-- )
+	for ( i = lim; i-- > 0; )
 	{
 	    sum = x_ve[i];
 	    r = &(A->row[i]);
 	    len = r->len;
 	    elt = &(r->elt[len-1]);
-	    for ( idx = len-1; idx >= 0 && elt->col > i; idx--, elt-- )
+	    for ( idx = len-1; idx >= 0 && elt->col > i; idx--, elt-- ) {
 		sum -= elt->val*x_ve[elt->col];
-	    if ( idx < 0 || elt->col != i || elt->val == 0.0 )
+	    }
+	    if ( idx < 0 || elt->col != i || elt->val == 0.0 ) {
 		error(E_SING,"spLUsolve");
+	    }
 	    x_ve[i] = sum/elt->val;
 	}
 
--- a/sptort.c
+++ b/sptort.c
@@ -39,9 +39,9 @@
 
 /* for iterative methods */
 
-#if REAL == DOUBLE
+#if MESCHACH_REAL == MESCHACH_DOUBLE
 #define	EPS	1e-7
-#elif REAL == FLOAT
+#elif MESCHACH_REAL == MESCHACH_FLOAT
 #define EPS   1e-3
 #endif
 
--- a/zmatio.c
+++ b/zmatio.c
@@ -53,18 +53,18 @@
 	    fprintf(stderr,"real and imag parts: ");
 	    if ( fgets(line,MAXLINE,fp) == NULL )
 		error(E_EOF,"z_finput");
-#if REAL == DOUBLE
+#if MESCHACH_REAL == MESCHACH_DOUBLE
 	    io_code = sscanf(line,"%lf%lf",&z.re,&z.im);
-#elif REAL == FLOAT
+#elif MESCHACH_REAL == MESCHACH_FLOAT
 	    io_code = sscanf(line,"%f%f",&z.re,&z.im);
 #endif
 
 	} while ( io_code != 2 );
     }
     else
-#if REAL == DOUBLE
+#if MESCHACH_REAL == MESCHACH_DOUBLE
       if ( (io_code=fscanf(fp," (%lf,%lf)",&z.re,&z.im)) < 2 )
-#elif REAL == FLOAT
+#elif MESCHACH_REAL == MESCHACH_FLOAT
       if ( (io_code=fscanf(fp," (%f,%f)",&z.re,&z.im)) < 2 )
 #endif
 	    error((io_code == EOF) ? E_EOF : E_FORMAT,"z_finput");
@@ -129,9 +129,9 @@
 		    if ( (*line == 'f' || *line == 'F') && j < n-1 )
 		    {   j++;    dynamic = FALSE;        goto redo2;     }
 	       } while ( *line=='\0' ||
-#if REAL == DOUBLE
+#if MESCHACH_REAL == MESCHACH_DOUBLE
 			 sscanf(line,"%lf%lf",
-#elif REAL == FLOAT
+#elif MESCHACH_REAL == MESCHACH_FLOAT
 			sscanf(line,"%f%f",
 #endif	
 				&mat->me[i][j].re,&mat->me[i][j].im)<1 );
@@ -176,9 +176,9 @@
 	  for ( j=0; j<n; j++ )
 	  {
 	      /* printf("bzm_finput: j = %d\n", j); */
-#if REAL == DOUBLE
+#if MESCHACH_REAL == MESCHACH_DOUBLE
 	      if ((io_code=fscanf(fp," ( %lf , %lf )",
-#elif REAL == FLOAT
+#elif MESCHACH_REAL == MESCHACH_FLOAT
 	      if ((io_code=fscanf(fp," ( %f , %f )",
 #endif
 				  &mat->me[i][j].re,&mat->me[i][j].im)) < 2 )
@@ -239,9 +239,9 @@
 	       if ( (*line == 'f' || *line == 'F') && i < dim-1 )
 	       {        i++;    dynamic = FALSE;        goto redo;         }
 	  } while ( *line=='\0' ||
-#if REAL == DOUBLE
+#if MESCHACH_REAL == MESCHACH_DOUBLE
 		    sscanf(line,"%lf%lf",
-#elif REAL == FLOAT
+#elif MESCHACH_REAL == MESCHACH_FLOAT
 		    sscanf(line,"%f%f",
 #endif  
 			   &vec->ve[i].re,&vec->ve[i].im) < 2 );
@@ -271,9 +271,9 @@
      /* get entries */
      skipjunk(fp);
      for ( i=0; i<dim; i++ )
-#if REAL == DOUBLE
+#if MESCHACH_REAL == MESCHACH_DOUBLE
 	  if ((io_code=fscanf(fp," (%lf,%lf)",
-#elif REAL == FLOAT
+#elif MESCHACH_REAL == MESCHACH_FLOAT
           if ((io_code=fscanf(fp," (%f,%f)",
 #endif
 			      &vec->ve[i].re,&vec->ve[i].im)) < 2 )
